name: Full CI/CD Pipeline

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  DOCKER_USERNAME: ahmedbutt3009
  BACKEND_IMAGE: movieapp-backend
  FRONTEND_IMAGE: movieapp-frontend

jobs:
  # Build and Test Stage
  test:
    name: Test & Lint
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Run frontend linter
        run: npm run lint || true

      - name: Build frontend
        run: npm run build

      - name: Install backend dependencies
        working-directory: ./backend
        run: npm ci

  # Build Docker Images
  build:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_USERNAME }}/${{ env.BACKEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.BACKEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.BACKEND_IMAGE }}:buildcache,mode=max

      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_USERNAME }}/${{ env.FRONTEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.FRONTEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.FRONTEND_IMAGE }}:buildcache,mode=max

  # Deploy to Kubernetes (only on master branch)
  deploy-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up SSH tunnel to EC2
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key.pem
          chmod 600 ~/.ssh/ec2_key.pem
          # Add EC2 to known_hosts
          ssh-keyscan -H ${{ secrets.EC2_HOST || '16.16.89.200' }} >> ~/.ssh/known_hosts 2>/dev/null || true
          # Start SSH tunnel in background (forwards localhost:6443 to EC2:localhost:6443)
          ssh -f -N -o StrictHostKeyChecking=no \
            -i ~/.ssh/ec2_key.pem \
            -L 6443:localhost:6443 \
            ${{ secrets.EC2_USER || 'ubuntu' }}@${{ secrets.EC2_HOST || '16.16.89.200' }}
          sleep 2
          echo "‚úÖ SSH tunnel started to ${{ secrets.EC2_HOST || '16.16.89.200' }}:6443"

      - name: Set up Kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          # Replace cluster server to use localhost tunnel
          sed -i 's|server:.*|server: https://127.0.0.1:6443|g' $HOME/.kube/config
          echo "‚úÖ Kubeconfig updated to use SSH tunnel (127.0.0.1:6443)"
          kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' || echo "‚ö†Ô∏è  Could not read cluster server"
          echo ""

      - name: Verify cluster connection
        run: |
          echo "üîå Attempting to connect to cluster through SSH tunnel..."
          kubectl cluster-info && kubectl get nodes || {
            echo "‚ùå Failed to connect to cluster"
            echo ""
            echo "üîç Troubleshooting:"
            echo "1. Check if SSH tunnel is running: ps aux | grep ssh"
            echo "2. Verify EC2_HOST and EC2_USER secrets are set"
            echo "3. Ensure EC2 security group allows SSH (port 22)"
            echo "4. Make sure Minikube is running on EC2"
            echo "5. Check if Minikube API server is listening on localhost:6443"
            exit 1
          }

      - name: Update deployment images
        run: |
          sed -i "s|image:.*movieapp-backend.*|image: ${{ env.DOCKER_USERNAME }}/${{ env.BACKEND_IMAGE }}:latest|g" k8s/deployment-backend.yaml
          sed -i "s|image:.*movieapp-frontend.*|image: ${{ env.DOCKER_USERNAME }}/${{ env.FRONTEND_IMAGE }}:latest|g" k8s/deployment-frontend.yaml
          sed -i "s|imagePullPolicy:.*|imagePullPolicy: Always|g" k8s/deployment-backend.yaml
          sed -i "s|imagePullPolicy:.*|imagePullPolicy: Always|g" k8s/deployment-frontend.yaml

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/configmap-nginx.yaml
          kubectl apply -f k8s/configmap-frontend-env.yaml
          kubectl apply -f k8s/configmap-frontend-script.yaml
          kubectl apply -f k8s/secret-backend.yaml
          kubectl apply -f k8s/deployment-backend.yaml
          kubectl apply -f k8s/service-backend.yaml
          kubectl apply -f k8s/deployment-frontend.yaml
          kubectl apply -f k8s/service-frontend.yaml

      - name: Wait for deployments
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/backend-deployment -n movieapp || true
          kubectl wait --for=condition=available --timeout=300s deployment/frontend-deployment -n movieapp || true

      - name: Show deployment status
        run: |
          kubectl get pods -n movieapp
          kubectl get services -n movieapp

      - name: Cleanup SSH tunnel
        if: always()
        run: |
          echo "üßπ Cleaning up SSH tunnel..."
          pkill -f "ssh.*6443:localhost:6443" || true
          echo "‚úÖ SSH tunnel closed"

