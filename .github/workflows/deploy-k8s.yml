name: Deploy to Kubernetes

on:
  push:
    branches: [ master ]
    paths:
      - 'k8s/**'
      - 'Dockerfile'
      - 'Dockerfile.frontend'
      - 'backend/**'
      - 'src/**'
      - '.github/workflows/deploy-k8s.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  DOCKER_USERNAME: ahmedbutt3009
  BACKEND_IMAGE: movieapp-backend
  FRONTEND_IMAGE: movieapp-frontend
  K8S_NAMESPACE: movieapp

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Set up SSH tunnel to EC2
        run: |
          mkdir -p ~/.ssh
          # Write SSH key and normalize line endings
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key.pem
          sed -i 's/\r$//' ~/.ssh/ec2_key.pem
          chmod 600 ~/.ssh/ec2_key.pem
          # Verify key format
          ssh-keygen -l -f ~/.ssh/ec2_key.pem || {
            echo "âš ï¸  SSH key format issue - checking first line:"
            head -1 ~/.ssh/ec2_key.pem
            echo "âŒ SSH key must be in OpenSSH or RSA format"
            exit 1
          }
          # Add EC2 to known_hosts
          ssh-keyscan -H ${{ secrets.EC2_HOST || '16.16.89.200' }} >> ~/.ssh/known_hosts 2>/dev/null || true
          # Start SSH tunnel in background (forwards localhost:6443 to EC2:localhost:6443)
          ssh -f -N -o StrictHostKeyChecking=no \
            -i ~/.ssh/ec2_key.pem \
            -L 6443:localhost:6443 \
            ${{ secrets.EC2_USER || 'ubuntu' }}@${{ secrets.EC2_HOST || '16.16.89.200' }}
          sleep 2
          # Verify tunnel is running
          if ps aux | grep -q "[s]sh.*6443:localhost:6443"; then
            echo "âœ… SSH tunnel started to ${{ secrets.EC2_HOST || '16.16.89.200' }}:6443"
          else
            echo "âŒ SSH tunnel failed to start"
            exit 1
          fi

      - name: Set up Kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          # Replace cluster server to use localhost tunnel
          sed -i 's|server:.*|server: https://127.0.0.1:6443|g' $HOME/.kube/config
          echo "âœ… Kubeconfig updated to use SSH tunnel (127.0.0.1:6443)"
          kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' || echo "âš ï¸  Could not read cluster server"
          echo ""

      - name: Verify cluster connection
        run: |
          echo "ðŸ”Œ Attempting to connect to cluster through SSH tunnel..."
          kubectl cluster-info && kubectl get nodes || {
            echo "âŒ Failed to connect to cluster"
            echo ""
            echo "ðŸ” Troubleshooting:"
            echo "1. Check if SSH tunnel is running: ps aux | grep ssh"
            echo "2. Verify EC2_HOST and EC2_USER secrets are set"
            echo "3. Ensure EC2 security group allows SSH (port 22)"
            echo "4. Make sure Minikube is running on EC2"
            echo "5. Check if Minikube API server is listening on localhost:6443"
            exit 1
          }

      - name: Get image tags
        id: image-tags
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BACKEND_TAG="latest"
            FRONTEND_TAG="latest"
          else
            BACKEND_TAG="${{ github.ref_name }}-${{ github.sha }}"
            FRONTEND_TAG="${{ github.ref_name }}-${{ github.sha }}"
          fi
          echo "backend_tag=${{ env.DOCKER_USERNAME }}/${{ env.BACKEND_IMAGE }}:$BACKEND_TAG" >> $GITHUB_OUTPUT
          echo "frontend_tag=${{ env.DOCKER_USERNAME }}/${{ env.FRONTEND_IMAGE }}:$FRONTEND_TAG" >> $GITHUB_OUTPUT
          echo "Backend image: ${{ env.DOCKER_USERNAME }}/${{ env.BACKEND_IMAGE }}:$BACKEND_TAG"
          echo "Frontend image: ${{ env.DOCKER_USERNAME }}/${{ env.FRONTEND_IMAGE }}:$FRONTEND_TAG"

      - name: Update deployment images
        run: |
          # Update backend deployment
          sed -i "s|image:.*movieapp-backend.*|image: ${{ steps.image-tags.outputs.backend_tag }}|g" k8s/deployment-backend.yaml
          # Update frontend deployment
          sed -i "s|image:.*movieapp-frontend.*|image: ${{ steps.image-tags.outputs.frontend_tag }}|g" k8s/deployment-frontend.yaml
          # Set image pull policy to Always for production
          sed -i "s|imagePullPolicy:.*|imagePullPolicy: Always|g" k8s/deployment-backend.yaml
          sed -i "s|imagePullPolicy:.*|imagePullPolicy: Always|g" k8s/deployment-frontend.yaml

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply ConfigMaps
        run: |
          kubectl apply -f k8s/configmap-nginx.yaml
          kubectl apply -f k8s/configmap-frontend-env.yaml
          kubectl apply -f k8s/configmap-frontend-script.yaml

      - name: Apply Secrets
        run: |
          kubectl apply -f k8s/secret-backend.yaml

      - name: Deploy Backend
        run: |
          kubectl apply -f k8s/deployment-backend.yaml
          kubectl apply -f k8s/service-backend.yaml

      - name: Deploy Frontend
        run: |
          kubectl apply -f k8s/deployment-frontend.yaml
          kubectl apply -f k8s/service-frontend.yaml

      - name: Wait for deployments
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/backend-deployment -n ${{ env.K8S_NAMESPACE }} || true
          kubectl wait --for=condition=available --timeout=300s deployment/frontend-deployment -n ${{ env.K8S_NAMESPACE }} || true

      - name: Show deployment status
        run: |
          echo "=== Pods Status ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}
          echo ""
          echo "=== Services Status ==="
          kubectl get services -n ${{ env.K8S_NAMESPACE }}
          echo ""
          echo "=== Deployments Status ==="
          kubectl get deployments -n ${{ env.K8S_NAMESPACE }}

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          kubectl rollout undo deployment/backend-deployment -n ${{ env.K8S_NAMESPACE }} || true
          kubectl rollout undo deployment/frontend-deployment -n ${{ env.K8S_NAMESPACE }} || true

      - name: Cleanup SSH tunnel
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up SSH tunnel..."
          pkill -f "ssh.*6443:localhost:6443" || true
          echo "âœ… SSH tunnel closed"

