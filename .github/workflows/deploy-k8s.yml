name: Deploy to Kubernetes

on:
  push:
    branches: [ master ]
    paths:
      - 'k8s/**'
      - 'Dockerfile'
      - 'Dockerfile.frontend'
      - 'backend/**'
      - 'src/**'
      - '.github/workflows/deploy-k8s.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  DOCKER_USERNAME: ahmedbutt3009
  BACKEND_IMAGE: movieapp-backend
  FRONTEND_IMAGE: movieapp-frontend
  K8S_NAMESPACE: movieapp

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Checkout code on EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST || '16.16.89.200' }}
          username: ${{ secrets.EC2_USER || 'ubuntu' }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "k8s/*"
          target: "/tmp/movieapp-k8s/k8s"
          strip_components: 0

      - name: Deploy on EC2 Minikube
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST || '16.16.89.200' }}
          username: ${{ secrets.EC2_USER || 'ubuntu' }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "ğŸ”§ Running kubectl inside EC2 where Minikube is accessible..."
            
            # Navigate to k8s directory
            cd /tmp/movieapp-k8s/k8s || { echo "âŒ k8s directory not found"; exit 1; }
            
            # Verify Minikube is running
            echo "ğŸ” Checking Minikube status..."
            if ! minikube status > /dev/null 2>&1; then
              echo "âŒ Minikube is not running!"
              echo "   Starting Minikube..."
              minikube start --apiserver-ips=127.0.0.1 --apiserver-port=6443 || exit 1
            fi
            
            # Verify cluster connection
            echo "ğŸ”Œ Verifying cluster connection..."
            kubectl cluster-info && kubectl get nodes || {
              echo "âŒ Failed to connect to Minikube cluster"
              exit 1
            }
            
            # Get image tags
            if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              BACKEND_TAG="latest"
              FRONTEND_TAG="latest"
            else
              BACKEND_TAG="${{ github.ref_name }}-${{ github.sha }}"
              FRONTEND_TAG="${{ github.ref_name }}-${{ github.sha }}"
            fi
            
            BACKEND_IMAGE="${{ env.DOCKER_USERNAME }}/${{ env.BACKEND_IMAGE }}:$BACKEND_TAG"
            FRONTEND_IMAGE="${{ env.DOCKER_USERNAME }}/${{ env.FRONTEND_IMAGE }}:$FRONTEND_TAG"
            
            echo "ğŸ“¦ Using images:"
            echo "   Backend: $BACKEND_IMAGE"
            echo "   Frontend: $FRONTEND_IMAGE"
            
            # Update deployment images
            echo "ğŸ“ Updating deployment images..."
            sed -i "s|image:.*movieapp-backend.*|image: $BACKEND_IMAGE|g" deployment-backend.yaml
            sed -i "s|image:.*movieapp-frontend.*|image: $FRONTEND_IMAGE|g" deployment-frontend.yaml
            sed -i "s|imagePullPolicy:.*|imagePullPolicy: Always|g" deployment-backend.yaml
            sed -i "s|imagePullPolicy:.*|imagePullPolicy: Always|g" deployment-frontend.yaml
            
            # Create namespace if not exists
            echo "ğŸ“¦ Creating namespace..."
            kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply ConfigMaps
            echo "ğŸ“ Applying ConfigMaps..."
            kubectl apply -f configmap-nginx.yaml
            kubectl apply -f configmap-frontend-env.yaml
            kubectl apply -f configmap-frontend-script.yaml
            
            # Apply Secrets
            echo "ğŸ” Applying Secrets..."
            kubectl apply -f secret-backend.yaml
            
            # Deploy Backend
            echo "ğŸš€ Deploying Backend..."
            kubectl apply -f deployment-backend.yaml
            kubectl apply -f service-backend.yaml
            
            # Deploy Frontend
            echo "ğŸš€ Deploying Frontend..."
            kubectl apply -f deployment-frontend.yaml
            kubectl apply -f service-frontend.yaml
            
            # Wait for deployments
            echo "â³ Waiting for deployments..."
            kubectl wait --for=condition=available --timeout=300s deployment/backend-deployment -n ${{ env.K8S_NAMESPACE }} || true
            kubectl wait --for=condition=available --timeout=300s deployment/frontend-deployment -n ${{ env.K8S_NAMESPACE }} || true
            
            # Show status
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“Š Deployment Status:"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "=== Pods ==="
            kubectl get pods -n ${{ env.K8S_NAMESPACE }}
            echo ""
            echo "=== Services ==="
            kubectl get services -n ${{ env.K8S_NAMESPACE }}
            echo ""
            echo "=== Deployments ==="
            kubectl get deployments -n ${{ env.K8S_NAMESPACE }}
            echo ""
            echo "âœ… Deployment complete!"
            
            # Rollback on failure
            if [ $? -ne 0 ]; then
              echo "âŒ Deployment failed, rolling back..."
              kubectl rollout undo deployment/backend-deployment -n ${{ env.K8S_NAMESPACE }} || true
              kubectl rollout undo deployment/frontend-deployment -n ${{ env.K8S_NAMESPACE }} || true
              exit 1
            fi

